// Generated by CoffeeScript 2.3.0
var S_IFDIR, S_IFLNK, S_IFMT, S_IFREG, copyFile, copyLink, copyTree, fs, getMode, path, removeTree, uhoh, writeDir;

path = require("path");

fs = require("fs");

// Constants used for determining file type.
({S_IFMT, S_IFREG, S_IFDIR, S_IFLNK} = fs.constants);

exports.ReadStream = fs.ReadStream;

exports.WriteStream = fs.WriteStream;

exports.open = fs.openSync;

exports.append = fs.appendFileSync;

exports.close = fs.closeSync;

exports.stat = fs.statSync;

exports.lstat = fs.lstatSync;

exports.touch = function(file) {
  var time;
  if (getMode(file) !== void 0) {
    time = Date.now() / 1000;
    fs.utimesSync(file, time, time);
    return;
  }
  fs.writeFileSync(file, '');
};

exports.read = function(file, opts) {
  if (typeof file === "number") {
    if (opts) {
      opts.fd = file;
    } else {
      opts = {
        fd: file
      };
    }
    file = null;
  }
  return new fs.ReadStream(file, opts);
};

exports.write = function(file, opts) {
  if (typeof file === "number") {
    if (opts) {
      opts.fd = file;
    } else {
      opts = {
        fd: file
      };
    }
    file = null;
  }
  return new fs.WriteStream(file, opts);
};

exports.exists = function(filePath) {
  return getMode(filePath) !== void 0;
};

exports.isDir = function(filePath) {
  return getMode(filePath) === S_IFDIR;
};

exports.isFile = function(filePath) {
  return getMode(filePath) === S_IFREG;
};

exports.isLink = function(filePath) {
  return getMode(filePath) === S_IFLNK;
};

exports.readDir = function(dirPath) {
  var mode;
  if (!(mode = getMode(dirPath))) {
    uhoh(`Cannot use \`readDir\` on a non-existent path: '${dirPath}'`, "DIR_NOT_FOUND");
  }
  if (mode !== S_IFDIR) {
    uhoh(`Expected a directory: '${dirPath}'`, "DIR_NOT_FOUND");
  }
  return fs.readdirSync(dirPath);
};

exports.readFile = function(filePath, encoding) {
  var mode;
  if (!(mode = getMode(filePath))) {
    uhoh(`Cannot use \`readFile\` on a non-existent path: '${filePath}'`, "FILE_NOT_FOUND");
  }
  if (mode === S_IFDIR) {
    uhoh(`Cannot use \`readFile\` on a directory: '${filePath}'`, "FILE_NOT_FOUND");
  }
  if (encoding === void 0) {
    encoding = "utf8";
  }
  return fs.readFileSync(filePath, encoding);
};

// Resolve the given path and its parents.
exports.realPath = fs.realpathSync;

exports.readLink = function(linkPath) {
  var mode;
  if (!(mode = getMode(linkPath))) {
    uhoh(`Cannot use \`readLink\` on a non-existent path: '${linkPath}'`, "LINK_NOT_FOUND");
  }
  if (mode === S_IFLNK) {
    return fs.readlinkSync(linkPath);
  }
  return linkPath;
};

exports.readLinks = function(linkPath, maxDepth = 100) {
  var depth, filePath, mode, prevPath;
  depth = 0;
  filePath = linkPath;
  while ((mode = getMode(filePath)) && (mode === S_IFLNK)) {
    prevPath = filePath;
    filePath = fs.readlinkSync(filePath);
    if (filePath[0] === ".") {
      filePath = path.resolve(path.dirname(prevPath), filePath);
    }
    if (++depth > maxDepth) {
      uhoh(`Failed to resolve link: '${linkPath}'`, "MAX_DEPTH");
    }
  }
  return filePath;
};

exports.writeDir = writeDir = function(dirPath) {
  var mode;
  if (!(mode = getMode(dirPath))) {
    writeDir(path.dirname(dirPath));
    return fs.mkdirSync(dirPath);
  }
  if (mode !== S_IFDIR) {
    return uhoh(`Cannot use \`writeDir\` on an existing path: '${dirPath}'`, "PATH_EXISTS");
  }
};

exports.writeFile = function(filePath, string) {
  if (getMode(filePath) !== S_IFDIR) {
    return fs.writeFileSync(filePath, string);
  }
  return uhoh(`Cannot use \`writeFile\` on a directory: '${filePath}'`, "PATH_EXISTS");
};

exports.writeLink = function(linkPath, targetPath) {
  if (!getMode(linkPath)) {
    return fs.symlinkSync(targetPath, linkPath);
  }
  return uhoh(`Cannot use \`writeLink\` on an existing path: '${linkPath}'`, "PATH_EXISTS");
};

exports.removeDir = function(dirPath, recursive = true) {
  var mode;
  if (!(mode = getMode(dirPath))) {
    return;
  }
  if (mode !== S_IFDIR) {
    uhoh(`Expected a directory: '${dirPath}'`, "DIR_NOT_FOUND");
  }
  if (".." === path.relative(process.cwd(), dirPath).slice(0, 2)) {
    uhoh(`Cannot use \`removeDir\` on paths outside of the current directory: '${dirPath}'`, "ABOVE_CWD");
  }
  if (recursive) {
    return removeTree(dirPath);
  }
  return fs.rmdirSync(dirPath);
};

exports.removeFile = function(filePath, mustExist = true) {
  var mode;
  if (!(mode = getMode(filePath))) {
    if (!mustExist) {
      return;
    }
    uhoh(`Cannot use \`removeFile\` on a non-existent path: '${filePath}'`, "FILE_NOT_FOUND");
  }
  if (mode === S_IFDIR) {
    uhoh(`Cannot use \`removeFile\` on a directory: '${filePath}'`, "DIR_EXISTS");
  }
  return fs.unlinkSync(filePath);
};

exports.rename = function(srcPath, destPath) {
  var mode;
  if (!(mode = getMode(srcPath))) {
    uhoh(`Cannot \`rename\` non-existent path: '${srcPath}'`, "SRC_NOT_FOUND");
  }
  if (mode === S_IFDIR) {
    if (getMode(destPath)) {
      uhoh(`Cannot \`rename\` directory to pre-existing path: '${destPath}'`, "DEST_EXISTS");
    }
  } else if (getMode(destPath) === S_IFDIR) {
    uhoh(`Cannot overwrite directory path: '${destPath}'`, "DEST_EXISTS");
  }
  writeDir(path.dirname(destPath));
  return fs.renameSync(srcPath, destPath);
};

exports.copy = function(srcPath, destPath) {
  var destMode, mode;
  if (!(mode = getMode(srcPath))) {
    uhoh(`Cannot \`copy\` non-existent path: '${srcPath}'`, "SRC_NOT_FOUND");
  }
  if (mode === S_IFDIR) {
    return copyTree(srcPath, destPath);
  }
  destMode = getMode(destPath);
  if (destMode === S_IFDIR) {
    destPath = path.join(destPath, path.basename(srcPath));
    destMode = getMode(destPath);
  }
  if (destMode) {
    if (destMode === S_IFDIR) {
      uhoh(`Cannot overwrite directory path: '${destPath}'`, "DEST_EXISTS");
    }
    fs.unlinkSync(destPath);
  }
  // Create missing parent directories.
  writeDir(path.dirname(destPath));
  if (mode === S_IFLNK) {
    return copyLink(srcPath, destPath);
  } else {
    return fs.writeFileSync(destPath, fs.readFileSync(srcPath));
  }
};

exports.watch = fs.watch;

exports.watchFile = fs.watchFile;


// Helpers

uhoh = function(message, code) {
  var e;
  e = Error(message);
  if (code) {
    e.code = code;
  }
  Error.captureStackTrace(e, uhoh);
  throw e;
};

getMode = function(filePath) {
  var mode;
  try {
    mode = fs.lstatSync(filePath).mode & S_IFMT;
  } catch (error) {}
  return mode;
};

copyLink = function(srcPath, destPath) {
  var filePath;
  filePath = fs.readlinkSync(srcPath);
  if (!path.isAbsolute(filePath)) {
    filePath = path.resolve(path.dirname(srcPath), filePath);
    filePath = path.relative(path.dirname(destPath), filePath);
  }
  return fs.symlinkSync(filePath, destPath);
};

// Overwrite the `destPath` with contents of the `srcPath`.
copyFile = function(srcPath, destPath) {
  var destMode, mode;
  mode = getMode(srcPath);
  if (mode === S_IFDIR) {
    return copyTree(srcPath, destPath);
  }
  if (destMode = getMode(destPath)) {
    if (destMode === S_IFDIR) {
      removeTree(destPath);
    } else {
      fs.unlinkSync(destPath);
    }
  }
  // Create missing parent directories.
  writeDir(path.dirname(destPath));
  if (mode === S_IFLNK) {
    return copyLink(srcPath, destPath);
  } else {
    return fs.writeFileSync(destPath, fs.readFileSync(srcPath));
  }
};

// Recursive tree copies.
copyTree = function(srcPath, destPath) {
  var destMode;
  destMode = getMode(destPath);
  // Remove the file under our new path, if needed.
  if (destMode && destMode !== S_IFDIR) {
    fs.unlinkSync(destPath);
  }
  // Create the directory, if needed.
  if (destMode !== S_IFDIR) {
    writeDir(path.dirname(destPath));
    fs.mkdirSync(destPath);
  }
  return fs.readdirSync(srcPath).forEach(function(file) {
    return copyFile(path.join(srcPath, file), path.join(destPath, file));
  });
};

// Recursive tree deletion.
removeTree = function(dirPath) {
  fs.readdirSync(dirPath).forEach(function(file) {
    var filePath;
    filePath = path.join(dirPath, file);
    if (getMode(filePath) === S_IFDIR) {
      return removeTree(filePath);
    } else {
      return fs.unlinkSync(filePath);
    }
  });
  return fs.rmdirSync(dirPath);
};
